---
title: "Take-home Exercise 1"
#subtitle: "Geospatial Data Wrangling with R"
description: "Application of Spatial Point Patterns Analysis to discover the geographical distribution of Grab hailing services in Singapore"
execute: 
  warning: false
  eval: true
  echo: true
# date: "`r Sys.Date()`"
date: 01/21/2024
date-format: "D MMM, YYYY" 
author: 
  - Wan Shen
sidebar: false
title-block-banner: true
categories:
  - Take-Home Exercise
title-block-categories: false
#format: 
  #html: 
    #code-fold: true
    #code-summary: "Show the code"
---

# 1.0 Getting Started

```{r}
pacman::p_load(sf, tidyverse, tmap, arrow, lubridate, maptools, raster, spatstat, spNetwork, classInt, viridis)
```

# 2.0 Spatial Data Wrangling

## 2.1 Importing the spatial data

Aspatial Data

```{r}
#| eval: false 
grab0 <- read_parquet("../../data/TakeHome/TakeHome_01/aspatial/part-00000.parquet") 
grab1 <- read_parquet("../../data/TakeHome/TakeHome_01/aspatial/part-00001.parquet")
grab2 <- read_parquet("../../data/TakeHome/TakeHome_01/aspatial/part-00002.parquet")
grab3 <- read_parquet("../../data/TakeHome/TakeHome_01/aspatial/part-00003.parquet")
grab4 <- read_parquet("../../data/TakeHome/TakeHome_01/aspatial/part-00004.parquet")
grab5 <- read_parquet("../../data/TakeHome/TakeHome_01/aspatial/part-00005.parquet")
grab6 <- read_parquet("../../data/TakeHome/TakeHome_01/aspatial/part-00006.parquet")
grab7 <- read_parquet("../../data/TakeHome/TakeHome_01/aspatial/part-00007.parquet")
grab8 <- read_parquet("../../data/TakeHome/TakeHome_01/aspatial/part-00008.parquet")
grab9 <- read_parquet("../../data/TakeHome/TakeHome_01/aspatial/part-00009.parquet")
```

Geospatial Data

```{r}
#| eval: false 
roadMe <- st_read("../../data/TakeHome/TakeHome_01/geospatial",
               layer = "gis_osm_roads_free_1")
head(roadMe, n=3)
```

```{r}
islandMe <- st_read(dsn="../../data/TakeHome/TakeHome_01/geospatial", layer="MPSZ-2019")
head(islandMe, n=3)
```

## 2.2 Data Pre-Processing

```{r}
#| eval: false
road_df <- roadMe[!(is.na(roadMe$name)), ]
island_df <- islandMe[!(is.na(islandMe$geometry)), ]
```

```{r}
#| eval: false 
merged_data <- bind_rows(grab0, grab1, grab2, grab3, grab4, grab5, grab6, grab7, grab8, grab9)
```

```{r}
#| eval: false
merged_data$pingtimestamp <- as_datetime(merged_data$pingtimestamp)
```

```{r}
#| eval: false
origin_df <- merged_data %>% 
  group_by(trj_id) %>%
  arrange(pingtimestamp) %>%
  filter(row_number()==1) %>%
  mutate(weekday = wday(pingtimestamp,
                        label=TRUE,
                        abbr=TRUE),
         start_hr = factor(hour(pingtimestamp)),
         day = factor(mday(pingtimestamp)))
origin_df
```

```{r}
#| eval: false
destination_df <- merged_data %>% 
  group_by(trj_id) %>%
  arrange(desc(pingtimestamp)) %>%
  filter(row_number()==1) %>%
  mutate(weekday = wday(pingtimestamp,
                        label=TRUE,
                        abbr=TRUE),
         end_hr = factor(hour(pingtimestamp)),
         day = factor(mday(pingtimestamp)))
destination_df
```

```{r}
#| eval: false 
#| echo: false 
write_rds(road_df, "../../data/TakeHome/TakeHome_01/rds/road_df.rds")
write_rds(island_df, "../../data/TakeHome/TakeHome_01/rds/island_df.rds")
```

```{r}
road_df <- read_rds("../../data/TakeHome/TakeHome_01/rds/road_df.rds")
island_df <- read_rds("../../data/TakeHome/TakeHome_01/rds/island_df.rds")
```

```{r}
#| eval: false
#| echo: false
write_rds(origin_df, "../../data/TakeHome/TakeHome_01/rds/origin_df.rds")
write_rds(destination_df, "../../data/TakeHome/TakeHome_01/rds/destination_df.rds")
```

```{r}
origin_df <- read_rds("../../data/TakeHome/TakeHome_01/rds/origin_df.rds")
destination_df <- read_rds("../../data/TakeHome/TakeHome_01/rds/destination_df.rds")
```

::: callout-note
Using the crs info function to retrieve the referencing system information of these geospatial data.
:::

```{r}
crs_info1 <- st_crs(road_df)
crs_info2 <- st_crs(island_df)
crs_info1
```

```{r}
crs_info2
```

::: callout-note
Preparing the following geospatial data layer in sf tibble data.frames.
:::

Road layer within Singapore excluding outer islands.

```{r}
tibble1 <- as_tibble(road_df)
tibble1
```

Singapore boundary layer excluding outer islands

```{r}
tibble2 <- as_tibble(island_df)
tibble2
```

::: callout-note
Changing the referencing system to Singapore national projected coordinate system.
:::

```{r}
road_sf <- st_transform(road_df, crs = 3414)
island_sf <- st_transform(island_df, crs = 3414)
```

```{r}
listings_sf <- st_as_sf(origin_df, 
                       coords = c("rawlng", "rawlat"),
                       crs=4326) %>%
  st_transform(crs = 3414)
glimpse(listings_sf)
```

```{r}
sf_df <- st_as_sf(road_sf, wkt = "geometry")
roads_in_singapore <- st_intersection(sf_df, island_sf)
```

## 2.3 Mapping the geospatial data sets

::: callout-note
After checking the referencing system of each geospatial data data frame, it is also useful for us to plot a map to show their spatial patterns.
:::

```{r}
roads_in_singapore <- st_transform(roads_in_singapore, crs = 3414)
```

Grab Taxi Location Points

```{r}
tmap_mode("plot")
tm_shape(listings_sf) +
  tm_dots()
```

Master Plan 2019 Planning Subzone Boundary with Grab Taxi Location Points

```{r}
tm_shape(island_sf) +
  tm_polygons() +
tm_shape(listings_sf) +
  tm_dots()
```

# 3.0 Geospatial Data wrangling

## 3.1 Converting sf data frames to sp’s Spatial\* class

::: callout-note
The code chunk below uses as_Spatial() of sf package to convert the three geospatial data from simple feature data frame to sp’s Spatial\* class.
:::

```{r}
#| eval: false
island <- as_Spatial(island_sf)
listings <- as_Spatial(listings_sf)
road <- as_Spatial(roads_in_singapore)
```

```{r}
#| eval: false
#| echo: false
write_rds(road, "../../data/TakeHome/TakeHome_01/rds/as_road_df.rds")
write_rds(island, "../../data/TakeHome/TakeHome_01/rds/as_island_df.rds")
write_rds(listings, "../../data/TakeHome/TakeHome_01/rds/as_listings_df.rds")
```

```{r}
road_as <- read_rds("../../data/TakeHome/TakeHome_01/rds/as_road_df.rds")
island_as <- read_rds("../../data/TakeHome/TakeHome_01/rds/as_island_df.rds")
listings_as <- read_rds("../../data/TakeHome/TakeHome_01/rds/as_listings_df.rds")
```

```{r}
island_as
```

```{r}
road_as
```

```{r}
listings_as
```

## 3.2 Converting the Spatial\* class into generic sp format

::: callout-note
Since spatstat requires the analytical data in ppp object form. There is no direct way to convert a Spatial\* classes into ppp object. We need to convert the Spatial classes\* into Spatial object first.

The codes chunk below converts the Spatial\* classes into generic sp objects.
:::

```{r}
#| eval: false
island_sp <- as(island_as, "SpatialPolygons")
road_sp <- as(road_as, "SpatialPoints")
```

```{r}
#| eval: false
#| echo: false
write_rds(road_sp, "../../data/TakeHome/TakeHome_01/rds/sp_road_df.rds")
write_rds(island_sp, "../../data/TakeHome/TakeHome_01/rds/sp_island_df.rds")
```

```{r}
road_sp <- read_rds("../../data/TakeHome/TakeHome_01/rds/sp_road_df.rds")
island_sp <- read_rds("../../data/TakeHome/TakeHome_01/rds/sp_island_df.rds")
```

```{r}
island_sp
```

```{r}
road_sp
```

## 3.3 Converting the generic sp format into spatstat’s ppp format

::: callout-note
Now, we will use as.ppp() function of spatstat to convert the spatial data into spatstat’s ppp object format.
:::

```{r}
road_ppp <- as(road_sp, "ppp")
```

```{r}
plot(road_ppp)
```

```{r}
summary(road_ppp)
```

```{r}
listings_ppp <- as.ppp(listings_as)
```

```{r}
summary(listings_ppp)
```

```{r}
sg_owin <- as(island_sp, "owin")
plot(sg_owin)
```

```{r}
glimpse(summary(sg_owin))
```

## 3.4 Combining point events object and owin object

In this last step of geospatial data wrangling, we will extract road events that are located within Singapore by using the code chunk below.

::: callout-note
Plot the newly derived islandSG_ppp as shown below.
:::

```{r}
islandSG_ppp_road = road_ppp[sg_owin]
```

```{r}
glimpse(summary(islandSG_ppp_road))
```

## 3.5 Handling duplicated points

We can check the duplication in a **ppp** object by using the code chunk below.

```{r}
any(duplicated(islandSG_ppp_road))
```

::: callout-note
To count the number of co-indicence point, we will use the multiplicity() function as shown in the code chunk below.
:::

```{r}
#| eval: false
multiplicity(islandSG_ppp_road)
```

::: callout-note
If we want to know how many locations have more than one point event, we can use the code chunk below.
:::

```{r}
sum(multiplicity(islandSG_ppp_road) > 1)
```

::: callout-note
The output shows that there are 165061 duplicated point events.

To view the locations of these duplicate point events, we will plot **road_as** data by using the c
:::

```{r}
tmap_mode('plot')
tm_shape(road_as) +
  tm_dots(alpha=0.4, 
          size=0.05)
```

```{r}
tmap_mode('plot')
tm_shape(listings_as) +
  tm_dots(alpha=0.4, 
          size=0.05)
```

::: callout-note
The solution is use jittering, which will add a small perturbation to the duplicate points so that they do not occupy the exact same space. The code chunk below implements the jittering approach.
:::

```{r}
road_ppp_jit <- rjitter(road_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)
```

```{r}
any(duplicated(road_ppp_jit))
```

```{r}
islandSG_ppp_road = road_ppp_jit[sg_owin]
plot(islandSG_ppp_road)
```

```{r}
islandSG_ppp_grab = listings_ppp[sg_owin]
```

```{r}
glimpse(summary(islandSG_ppp_grab))
```

# 4.0 Kernel Density Estimation

## 4.1 Computing kernel density estimation using automatic bandwidth selection method

The code chunk below computes a kernel density by using the following configurations of density() of spatstat:

-   [*bw.diggle()*](https://rdrr.io/cran/spatstat/man/bw.diggle.html) automatic bandwidth selection method. Other recommended methods are [*bw.CvL()*](https://rdrr.io/cran/spatstat/man/bw.CvL.html), [*bw.scott()*](https://rdrr.io/cran/spatstat/man/bw.scott.html) or [*bw.ppl()*](https://rdrr.io/cran/spatstat/man/bw.ppl.html).

-   The smoothing kernel used is *gaussian*, which is the default. Other smoothing methods are: “epanechnikov”, “quartic” or “disc”.

-   The intensity estimate is corrected for edge effect bias by using method described by Jones (1993) and Diggle (2010, equation 18.9). The default is *FALSE*.

```{r}
kde_grab_bw <- density(listings_ppp,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian") 
```

```{r}
kde_roadSG_bw <- density(road_ppp,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian") 
```

```{r}
plot(kde_grab_bw)
```

```{r}
bw1 <- bw.diggle(listings_ppp)
bw1
```

```{r}
plot(kde_roadSG_bw)
```

```{r}
bw2 <- bw.diggle(road_ppp)
bw2
```

## 4.2 Rescalling KDE values

In the code chunk below, rescale() is used to covert the unit of measurement from meter to kilometer.

```{r}
grab_ppp.km <- rescale(listings_ppp, 1000, "km")
```

```{r}
kde_grab.bw <- density(grab_ppp.km, sigma=bw.diggle, edge=TRUE, kernel="gaussian")
plot(kde_grab.bw)
```

```{r}
road_ppp.km <- rescale(road_ppp, 1000, "km")
```

```{r}
kde_roadSG.bw <- density(road_ppp.km, sigma=bw.diggle, edge=TRUE, kernel="gaussian")
plot(kde_roadSG.bw)
```

## 4.3 Working with different automatic badwidth methods

Beside bw.diggle(), there are three other **spatstat** functions can be used to determine the bandwidth, they are: bw.CvL(), bw.scott(), and bw.ppl().

Let us take a look at the bandwidth return by these automatic bandwidth calculation methods by using the code chunk below.

```{r}
bw.scott(grab_ppp.km)
```

```{r}
bw.diggle(grab_ppp.km)
```

```{r}
kde_grab.scott <- density(grab_ppp.km, 
                               sigma=bw.scott, 
                               edge=TRUE,
                               kernel="gaussian")
par(mfrow=c(1,2))
plot(kde_grab.bw, main = "bw.diggle")
plot(kde_grab.scott, main = "bw.scott")
```

```{r}
bw.scott(road_ppp.km)
```

```{r}
bw.diggle(road_ppp.km)
```

```{r}
kde_roadSG.scott <- density(road_ppp.km, 
                               sigma=bw.scott, 
                               edge=TRUE,
                               kernel="gaussian")
par(mfrow=c(1,2))
plot(kde_roadSG.bw, main = "bw.diggle")
plot(kde_roadSG.scott, main = "bw.scott")
```

## 4.4 Converting KDE output into grid object

```{r}
gridded_kde_grab_bw <- as.SpatialGridDataFrame.im(kde_grab.bw)
spplot(gridded_kde_grab_bw)
```

```{r}
gridded_kde_roadSG_bw <- as.SpatialGridDataFrame.im(kde_roadSG.bw)
spplot(gridded_kde_roadSG_bw)
```

## 4.5 Converting gridded output into raster

Next, we will convert the gridded kernal density objects into RasterLayer object by using *raster()* of **raster** package.

```{r}
kde_kde_grab_bw_raster <- raster(gridded_kde_grab_bw)
```

```{r}
kde_kde_roadSG_bw_raster <- raster(gridded_kde_roadSG_bw)
```

::: callout-note
Let us take a look at the properties of kde_roadSG_bw_raster RasterLayer.
:::

```{r}
kde_kde_grab_bw_raster
```

```{r}
kde_kde_roadSG_bw_raster
```

::: callout-note
Notice that the crs property is NA.
:::

## 4.6 Assigning projection systems

::: callout-note
The code chunk below will be used to include the CRS information on kde_roadSG_bw_raster RasterLayer.
:::

```{r}
projection(kde_kde_grab_bw_raster) <- CRS("+init=EPSG:3414")
kde_kde_grab_bw_raster
```

```{r}
projection(kde_kde_roadSG_bw_raster) <- CRS("+init=EPSG:3414")
kde_kde_roadSG_bw_raster
```

::: callout-note
Notice that the crs property is completed.
:::

# 5.0 Visualising the output in tmap

::: callout-note
Finally, we will display the raster in cartographic quality map using tmap package.
:::

```{r}
tm_shape(kde_kde_grab_bw_raster) + 
  tm_raster("v") +
  tm_layout(legend.position = c("right", "bottom"), frame = FALSE)
```

```{r}
tm_shape(kde_kde_roadSG_bw_raster) + 
  tm_raster("v") +
  tm_layout(legend.position = c("right", "bottom"), frame = FALSE)
```

::: callout-note
Using appropriate tmap functions, display the kernel density layers on openstreetmap of Singapore
:::

```{r}
osm_layer <- qtm(basemaps = "OpenStreetMap", zoom = 12)
```

```{r}
tmap_mode("plot")
tm_shape(kde_kde_grab_bw_raster) +
  tm_raster(style = "cont", palette = "plasma") +
  tm_layout(legend.show = TRUE, legend.text.color = "white") +
  osm_layer
```

```{r}
tmap_mode("plot")
tm_shape(kde_kde_roadSG_bw_raster) +
  tm_raster(style = "cont", palette = "plasma") +
  tm_layout(legend.show = TRUE, legend.text.color = "white") +
  osm_layer
```

# 6.0 Network Constrained KDE (NetKDE) Analysis

In this section, we will perform NetKDE analysis by using appropriate functions provided in **spNetwork** package.

## 6.1 Extracting study area

```{r}
pung <- islandMe %>%
  filter(PLN_AREA_N == "PUNGGOL")
pung <- pung%>%
  st_union()
pung <- st_make_valid(pung)
length(which(st_is_valid(pung) == FALSE))
```

```{r}
tamp <- islandMe %>%
  filter(PLN_AREA_N == "TAMPINES")
tamp <- tamp%>%
  st_union()
tamp <- st_make_valid(tamp)
length(which(st_is_valid(tamp) == FALSE))
```

```{r}
cck <- islandMe %>%
  filter(PLN_AREA_N == "CHOA CHU KANG")
cck <- cck%>%
  st_union()
cck <- st_make_valid(cck)
length(which(st_is_valid(cck) == FALSE))
```

```{r}
jw <- islandMe %>%
  filter(PLN_AREA_N == "JURONG WEST")
jw <- jw%>%
  st_union()
jw <- st_make_valid(jw)
length(which(st_is_valid(jw) == FALSE))
```

```{r}
pung <- st_transform(pung, crs = 3414)
tamp <- st_transform(tamp, crs = 3414)
cck <- st_transform(cck, crs = 3414)
jw <- st_transform(jw, crs = 3414)
```

```{r}
pung_roads <- st_intersection(roads_in_singapore, pung)
tamp_roads <- st_intersection(roads_in_singapore, tamp)
cck_roads <- st_intersection(roads_in_singapore, cck)
jw_roads <- st_intersection(roads_in_singapore, jw)
```

```{r}
par(mfrow=c(2,2))
plot(pung, main = "Punggol")
plot(tamp, main = "Tampines")
plot(cck, main = "Choa Chu Kang")
plot(jw, main = "Jurong West")
```

```{r}
tmap_mode('plot')
tmap_arrange(tm_shape(pung_roads) +
               tm_lines(col = "red") +
               tm_layout(title = "Punggol", title.size = 0.8),
             tm_shape(tamp_roads) +
               tm_lines(col = "blue") +
               tm_layout(title = "Tampines", title.size = 0.8), 
             tm_shape(cck_roads) +
               tm_lines(col = "green") +
               tm_layout(title = "Choa Chu Kang", title.size = 0.8),
             tm_shape(jw_roads) +
               tm_lines(col = "orange") +
               tm_layout(title = "Jurong West", title.size = 0.8),
             asp=2, ncol=2)
```

```{r}
pung_roads <- st_cast(pung_roads, "LINESTRING")
tamp_roads <- st_cast(tamp_roads, "LINESTRING")
cck_roads <- st_cast(cck_roads, "LINESTRING")
jw_roads <- st_cast(jw_roads, "LINESTRING")
```

## 6.2 Preparing the lixels objects

Before computing NetKDE, the SpatialLines object need to be cut into lixels with a specified minimal distance. This task can be performed by using with lixelize_lines() of spNetwork as shown in the code chunk below.

```{r}
lixels_pung <- lixelize_lines(pung_roads, 
                         700, 
                         mindist = 350)
lixels_tamp <- lixelize_lines(tamp_roads, 
                         700, 
                         mindist = 350)
lixels_cck <- lixelize_lines(cck_roads, 
                         700, 
                         mindist = 350)
lixels_jw <- lixelize_lines(jw_roads, 
                         700, 
                         mindist = 350)
```

## 6.3 Generating line centre points

Next, lines_center() of **spNetwork** will be used to generate a SpatialPointsDataFrame (i.e. samples) with line centre points as shown in the code chunk below.

```{r}
samples_pung <- lines_center(lixels_pung)
samples_tamp <- lines_center(lixels_tamp)
samples_cck <- lines_center(lixels_cck)
samples_jw <- lines_center(lixels_jw)
```

```{r}
origin_pung = st_intersection(listings_sf, pung)
origin_tamp = st_intersection(listings_sf, tamp)
origin_cck = st_intersection(listings_sf, cck)
origin_jw = st_intersection(listings_sf, jw)
```

```{r}
tmap_mode('view')
tm_basemap("OpenStreetMap") +
tm_shape(cck_roads) +
  tm_lines(col = "green") +
  tm_shape(origin_cck) + 
  tm_dots()
tmap_mode('plot')
```

The points are located at center of the line based on the length of the line.

## 6.4 Performing NetKDE

We are ready to compute the NetKDE by using the code chunk below.

```{r}
densities_cck <- nkde(cck_roads, 
                  events = origin_cck,
                  w = rep(1,nrow(origin_cck)),
                  samples = samples_cck,
                  kernel_name = "quartic",
                  bw = 300, 
                  div= "bw", 
                  method = "simple", 
                  digits = 1, 
                  tol = 1,
                  grid_shape = c(1,1), 
                  max_depth = 8,
                  agg = 5, #we aggregate events within a 5m radius (faster calculation)
                  sparse = TRUE,
                  verbose = FALSE)
```

```{r}
samples_cck$density <- densities_cck
lixels_cck$density <- densities_cck
# rescaling to help the mapping
samples_cck$density <- samples_cck$density*1000
lixels_cck$density <- lixels_cck$density*1000
```

::: {.panel-tabset}
```{r}
## Choa Chu Kang
tmap_mode('plot')
tm_shape(lixels_cck)+
  tm_lines(col="density")+
tm_shape(origin_cck)+
  tm_dots()
```
```{r}
## Punggol
#tmap_mode('plot')
#tm_shape(lixels_pung)+
#  tm_lines(col="density")+
#tm_shape(origin_pung)+
#  tm_dots()
```
:::