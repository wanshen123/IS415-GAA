---
title: "Take-home Exercise 1"
description: "Application of Spatial Point Patterns Analysis to discover the geographical distribution of Grab hailing services in Singapore"
execute: 
  warning: false
  eval: true
  echo: true
# date: "`r Sys.Date()`"
date: 01/21/2024
date-format: "D MMM, YYYY" 
author: 
  - Wan Shen
sidebar: false
title-block-banner: true
categories:
  - Take-Home Exercise
title-block-categories: false
format: html 
---

# 1.0 Getting Started

**Background**

In this study, we examine the spatial and temporal spread of Grab ride-hailing services in Singapore, utilizing the extensive dataset offered by Grab, known as Grab Posisi. As a prominent provider of shared taxi services in Southeast Asia, Grab's dataset provides valuable insights into human mobility. Our research concentrates on employing Spatial Point Pattern Analyses (KDE/NKDE) to uncover underlying patterns within this dataset.

**Packages Used:**

-   [**sf**](https://cran.r-project.org/web/packages/sf/index.html): For importing, managing, and processing geospatial data.

-   [**tidyverse**](https://www.tidyverse.org/): Collection of packages for data science tasks.

-   [**tmap**](https://cran.r-project.org/web/packages/tmap/index.html): For creating thematic maps, such as choropleth and bubble maps.

-   [**spatstat**](https://spatstat.org/): For point pattern analysis.

-   [**raster**](https://cran.r-project.org/web/packages/raster/): Reads, writes, manipulates, analyses and models gridded spatial data.

-   [**maptools**](https://cran.r-project.org/web/packages/maptools/index.html): A set of tools for manipulating geographic data.

-   [**classInt**](https://cran.r-project.org/web/packages/classInt/index.html): Selected commonly used methods for choosing univariate class intervals for mapping or other graphics purposes.

-   [**spNetwork**](https://cran.r-project.org/web/packages/spNetwork/index.html): Perform spatial analysis on network.

-   [**viridis**](https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html): Make plots that are pretty, better represent your data and easier to read by those with colorblindness.

-   [**arrow**](https://arrow.apache.org/docs/r/): Work with parquet files and to load the GrabPosisi dataset.

```{r}
pacman::p_load(sf, tidyverse, tmap, maptools, raster, spatstat, spNetwork, classInt, viridis, arrow)
```

# 2.0 Spatial Data Wrangling

## 2.1 Importing the spatial data

Aspatial Data

```{r}
#| eval: false 
grab0 <- read_parquet("../../data/TakeHome/TakeHome_01/aspatial/part-00000.parquet") 
grab1 <- read_parquet("../../data/TakeHome/TakeHome_01/aspatial/part-00001.parquet")
grab2 <- read_parquet("../../data/TakeHome/TakeHome_01/aspatial/part-00002.parquet")
grab3 <- read_parquet("../../data/TakeHome/TakeHome_01/aspatial/part-00003.parquet")
grab4 <- read_parquet("../../data/TakeHome/TakeHome_01/aspatial/part-00004.parquet")
grab5 <- read_parquet("../../data/TakeHome/TakeHome_01/aspatial/part-00005.parquet")
grab6 <- read_parquet("../../data/TakeHome/TakeHome_01/aspatial/part-00006.parquet")
grab7 <- read_parquet("../../data/TakeHome/TakeHome_01/aspatial/part-00007.parquet")
grab8 <- read_parquet("../../data/TakeHome/TakeHome_01/aspatial/part-00008.parquet")
grab9 <- read_parquet("../../data/TakeHome/TakeHome_01/aspatial/part-00009.parquet")
```

Geospatial Data

```{r}
#| eval: false 
roadMe <- st_read("../../data/TakeHome/TakeHome_01/geospatial",
               layer = "gis_osm_roads_free_1")
head(roadMe, n=3)
```

```{r}
islandMe <- st_read(dsn="../../data/TakeHome/TakeHome_01/geospatial", layer="MPSZ-2019")
head(islandMe, n=3)
```

## 2.2 Data Pre-Processing

Remove rows with missing values

```{r}
#| eval: false
road_df <- roadMe[!(is.na(roadMe$name)), ]
island_df <- islandMe[!(is.na(islandMe$geometry)), ]
```

Combine all grab data into one

```{r}
#| eval: false 
merged_data <- bind_rows(grab0, grab1, grab2, grab3, grab4, grab5, grab6, grab7, grab8, grab9)
```

Formatting **pingtimestamp** into date & time

```{r}
#| eval: false
merged_data$pingtimestamp <- as_datetime(merged_data$pingtimestamp)
```

Retrieve all origin locations data

```{r}
#| eval: false
origin_df <- merged_data %>% 
  group_by(trj_id) %>%
  arrange(pingtimestamp) %>%
  filter(row_number()==1) %>%
  mutate(weekday = wday(pingtimestamp,
                        label=TRUE,
                        abbr=TRUE),
         start_hr = factor(hour(pingtimestamp)),
         day = factor(mday(pingtimestamp)))
origin_df
```

Retrieve all destination locations data

```{r}
#| eval: false
destination_df <- merged_data %>% 
  group_by(trj_id) %>%
  arrange(desc(pingtimestamp)) %>%
  filter(row_number()==1) %>%
  mutate(weekday = wday(pingtimestamp,
                        label=TRUE,
                        abbr=TRUE),
         end_hr = factor(hour(pingtimestamp)),
         day = factor(mday(pingtimestamp)))
destination_df
```

```{r}
#| eval: false 
#| echo: false 
write_rds(road_df, "../../data/TakeHome/TakeHome_01/rds/road_df.rds")
write_rds(island_df, "../../data/TakeHome/TakeHome_01/rds/island_df.rds")
```

```{r}
road_df <- read_rds("../../data/TakeHome/TakeHome_01/rds/road_df.rds")
island_df <- read_rds("../../data/TakeHome/TakeHome_01/rds/island_df.rds")
```

```{r}
#| eval: false
#| echo: false
write_rds(origin_df, "../../data/TakeHome/TakeHome_01/rds/origin_df.rds")
write_rds(destination_df, "../../data/TakeHome/TakeHome_01/rds/destination_df.rds")
```

```{r}
origin_df <- read_rds("../../data/TakeHome/TakeHome_01/rds/origin_df.rds")
destination_df <- read_rds("../../data/TakeHome/TakeHome_01/rds/destination_df.rds")
```

::: callout-note
Using the crs info function to retrieve the referencing system information of these geospatial data.
:::

```{r}
crs_info1 <- st_crs(road_df)
crs_info2 <- st_crs(island_df)
crs_info1
```

```{r}
crs_info2
```

::: callout-note
Changing the referencing system to Singapore national projected coordinate system.
:::

```{r}
road_sf <- st_transform(road_df, crs = 3414)
island_sf <- st_transform(island_df, crs = 3414)
```

```{r}
listings_sf <- st_as_sf(origin_df, 
                       coords = c("rawlng", "rawlat"),
                       crs=4326) %>%
  st_transform(crs = 3414)
glimpse(listings_sf)
```

Retrieve all roads within Singapore only

```{r}
sf_df <- st_as_sf(road_sf, wkt = "geometry")
roads_in_singapore <- st_intersection(sf_df, island_sf)
```

::: callout-note
Preparing the following geospatial data layer in sf tibble data.frames.
:::

Road layer within Singapore excluding outer islands.

```{r}
tibble1 <- as_tibble(roads_in_singapore)
tibble1
```

Singapore boundary layer excluding outer islands

```{r}
tibble2 <- as_tibble(island_df)
tibble2
```

## 2.3 Mapping the geospatial data sets

After checking the referencing system of each geospatial data data frame, it is also useful for us to plot a map to show their spatial patterns.

```{r}
roads_in_singapore <- st_transform(roads_in_singapore, crs = 3414)
```

Grab Taxi Location Points

```{r}
tmap_mode("plot")
tm_shape(listings_sf) +
  tm_dots()
```

Master Plan 2019 Planning Subzone Boundary with Grab Taxi Location Points

```{r}
tm_shape(island_sf) +
  tm_polygons() +
tm_shape(listings_sf) +
  tm_dots()
```

# 3.0 Geospatial Data wrangling

## 3.1 Converting sf data frames to sp’s Spatial\* class

The code chunk below uses as_Spatial() of sf package to convert the three geospatial data from simple feature data frame to sp’s Spatial\* class.

```{r}
#| eval: false
island <- as_Spatial(island_sf)
listings <- as_Spatial(listings_sf)
road <- as_Spatial(roads_in_singapore)
```

```{r}
#| eval: false
#| echo: false
write_rds(road, "../../data/TakeHome/TakeHome_01/rds/as_road_df.rds")
write_rds(island, "../../data/TakeHome/TakeHome_01/rds/as_island_df.rds")
write_rds(listings, "../../data/TakeHome/TakeHome_01/rds/as_listings_df.rds")
```

```{r}
road_as <- read_rds("../../data/TakeHome/TakeHome_01/rds/as_road_df.rds")
island_as <- read_rds("../../data/TakeHome/TakeHome_01/rds/as_island_df.rds")
listings_as <- read_rds("../../data/TakeHome/TakeHome_01/rds/as_listings_df.rds")
```

```{r}
island_as
```

```{r}
road_as
```

```{r}
listings_as
```

## 3.2 Converting the Spatial\* class into generic sp format

Since spatstat requires the analytical data in ppp object form. There is no direct way to convert a Spatial\* classes into ppp object. We need to convert the Spatial classes\* into Spatial object first.

The codes chunk below converts the Spatial\* classes into generic sp objects.

```{r}
#| eval: false
island_sp <- as(island_as, "SpatialPolygons")
road_sp <- as(road_as, "SpatialPoints")
```

```{r}
#| eval: false
#| echo: false
write_rds(road_sp, "../../data/TakeHome/TakeHome_01/rds/sp_road_df.rds")
write_rds(island_sp, "../../data/TakeHome/TakeHome_01/rds/sp_island_df.rds")
```

```{r}
road_sp <- read_rds("../../data/TakeHome/TakeHome_01/rds/sp_road_df.rds")
island_sp <- read_rds("../../data/TakeHome/TakeHome_01/rds/sp_island_df.rds")
```

```{r}
island_sp
```

```{r}
road_sp
```

## 3.3 Converting the generic sp format into spatstat’s ppp format

Now, we will use as.ppp() function of spatstat to convert the spatial data into spatstat’s ppp object format.

```{r}
road_ppp <- as(road_sp, "ppp")
```

```{r}
plot(road_ppp)
```

```{r}
summary(road_ppp)
```

```{r}
listings_ppp <- as.ppp(listings_as)
```

```{r}
summary(listings_ppp)
```

## 3.4 Creating owin object

When analysing spatial point patterns, it is a good practice to confine the analysis with a geographical area like Singapore boundary. In spatstat, an object called owin is specially designed to represent this polygonal region.

The code chunk below is used to covert sg SpatialPolygon object into owin object of spatstat.

```{r}
sg_owin <- as(island_sp, "owin")
plot(sg_owin)
```

```{r}
glimpse(summary(sg_owin))
```

## 3.5 Combining point events object and owin object

In this last step of geospatial data wrangling, we will extract road events that are located within Singapore by using the code chunk below.

```{r}
islandSG_ppp_road = road_ppp[sg_owin]
```

```{r}
glimpse(summary(islandSG_ppp_road))
```

## 3.6 Handling duplicated points

We can check the duplication in a **ppp** object by using the code chunk below.

```{r}
any(duplicated(islandSG_ppp_road))
```

::: callout-note
To count the number of co-indicence point, we will use the multiplicity() function as shown in the code chunk below.
:::

```{r}
#| eval: false
multiplicity(islandSG_ppp_road)
```

::: callout-note
If we want to know how many locations have more than one point event, we can use the code chunk below.
:::

```{r}
sum(multiplicity(islandSG_ppp_road) > 1)
```

::: callout-note
The output shows that there are 165793 duplicated point events.

To view the locations of these duplicate point events, we will plot **road_as** data by using the c
:::

```{r}
tmap_mode('plot')
tm_shape(road_as) +
  tm_dots(alpha=0.4, 
          size=0.05)
```

```{r}
tmap_mode('plot')
tm_shape(listings_as) +
  tm_dots(alpha=0.4, 
          size=0.05)
```

::: callout-note
The solution is use jittering, which will add a small perturbation to the duplicate points so that they do not occupy the exact same space. The code chunk below implements the jittering approach.
:::

```{r}
road_ppp_jit <- rjitter(road_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)
```

```{r}
any(duplicated(road_ppp_jit))
```

```{r}
islandSG_ppp_road = road_ppp_jit[sg_owin]
plot(islandSG_ppp_road)
```

```{r}
islandSG_ppp_grab = listings_ppp[sg_owin]
```

```{r}
glimpse(summary(islandSG_ppp_grab))
```

# 4.0 Kernel Density Estimation

## 4.1 Computing kernel density estimation using automatic bandwidth selection method

The code chunk below computes a kernel density by using the following configurations of density() of spatstat:

-   [*bw.diggle()*](https://rdrr.io/cran/spatstat/man/bw.diggle.html) automatic bandwidth selection method. Other recommended methods are [*bw.CvL()*](https://rdrr.io/cran/spatstat/man/bw.CvL.html), [*bw.scott()*](https://rdrr.io/cran/spatstat/man/bw.scott.html) or [*bw.ppl()*](https://rdrr.io/cran/spatstat/man/bw.ppl.html).

-   The smoothing kernel used is *gaussian*, which is the default. Other smoothing methods are: “epanechnikov”, “quartic” or “disc”.

-   The intensity estimate is corrected for edge effect bias by using method described by Jones (1993) and Diggle (2010, equation 18.9). The default is *FALSE*.

```{r}
kde_grab_bw <- density(listings_ppp,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian") 
```

```{r}
kde_roadSG_bw <- density(road_ppp,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian") 
```

```{r}
plot(kde_grab_bw)
```

```{r}
bw1 <- bw.diggle(listings_ppp)
bw1
```

```{r}
plot(kde_roadSG_bw)
```

```{r}
bw2 <- bw.diggle(road_ppp)
bw2
```

## 4.2 Rescalling KDE values

In the code chunk below, rescale() is used to covert the unit of measurement from meter to kilometer.

```{r}
grab_ppp.km <- rescale(listings_ppp, 1000, "km")
```

```{r}
kde_grab.bw <- density(grab_ppp.km, sigma=bw.diggle, edge=TRUE, kernel="gaussian")
plot(kde_grab.bw)
```

```{r}
road_ppp.km <- rescale(road_ppp, 1000, "km")
```

```{r}
kde_roadSG.bw <- density(road_ppp.km, sigma=bw.diggle, edge=TRUE, kernel="gaussian")
plot(kde_roadSG.bw)
```

## 4.3 Working with different automatic badwidth methods

Beside bw.diggle(), there are three other **spatstat** functions can be used to determine the bandwidth, they are: bw.CvL(), bw.scott(), and bw.ppl().

Let us take a look at the bandwidth return by these automatic bandwidth calculation methods by using the code chunk below.

```{r}
bw.scott(grab_ppp.km)
```

```{r}
bw.diggle(grab_ppp.km)
```

```{r}
kde_grab.scott <- density(grab_ppp.km, 
                               sigma=bw.scott, 
                               edge=TRUE,
                               kernel="gaussian")
par(mfrow=c(1,2))
plot(kde_grab.bw, main = "bw.diggle")
plot(kde_grab.scott, main = "bw.scott")
```

```{r}
bw.scott(road_ppp.km)
```

```{r}
bw.diggle(road_ppp.km)
```

```{r}
kde_roadSG.scott <- density(road_ppp.km, 
                               sigma=bw.scott, 
                               edge=TRUE,
                               kernel="gaussian")
par(mfrow=c(1,2))
plot(kde_roadSG.bw, main = "bw.diggle")
plot(kde_roadSG.scott, main = "bw.scott")
```

## 4.4 Converting KDE output into grid object

Now we convert it so that it is suitable for mapping purposes.

```{r}
gridded_kde_grab_bw <- as.SpatialGridDataFrame.im(kde_grab.bw)
spplot(gridded_kde_grab_bw)
```

```{r}
gridded_kde_roadSG_bw <- as.SpatialGridDataFrame.im(kde_roadSG.bw)
spplot(gridded_kde_roadSG_bw)
```

## 4.5 Converting gridded output into raster

Next, we will convert the gridded kernal density objects into RasterLayer object by using *raster()* of **raster** package.

```{r}
kde_kde_grab_bw_raster <- raster(gridded_kde_grab_bw)
```

```{r}
kde_kde_roadSG_bw_raster <- raster(gridded_kde_roadSG_bw)
```

::: callout-note
Let us take a look at the properties of kde_roadSG_bw_raster RasterLayer.
:::

```{r}
kde_kde_grab_bw_raster
```

```{r}
kde_kde_roadSG_bw_raster
```

::: callout-note
Notice that the crs property is NA.
:::

## 4.6 Assigning projection systems

The code chunk below will be used to include the CRS information on kde_roadSG_bw_raster RasterLayer.

```{r}
projection(kde_kde_grab_bw_raster) <- CRS("+init=EPSG:3414")
kde_kde_grab_bw_raster
```

```{r}
projection(kde_kde_roadSG_bw_raster) <- CRS("+init=EPSG:3414")
kde_kde_roadSG_bw_raster
```

::: callout-note
Notice that the crs property is completed.
:::

# 5.0 Visualising the output in tmap

Finally, we will display the raster in cartographic quality map using tmap package.

```{r}
tm_shape(kde_kde_grab_bw_raster) + 
  tm_raster("v") +
  tm_layout(legend.position = c("right", "bottom"), frame = FALSE)
```

```{r}
tm_shape(kde_kde_roadSG_bw_raster) + 
  tm_raster("v") +
  tm_layout(legend.position = c("right", "bottom"), frame = FALSE)
```

::: callout-note
Using appropriate tmap functions, display the kernel density layers on openstreetmap of Singapore
:::

```{r}
osm_layer <- qtm(basemaps = "OpenStreetMap", zoom = 12)
```

```{r}
tmap_mode("plot")
tm_shape(kde_kde_grab_bw_raster) +
  tm_raster(style = "cont", palette = "plasma") +
  tm_layout(legend.show = TRUE, legend.text.color = "white") +
  osm_layer
```

```{r}
tmap_mode("plot")
tm_shape(kde_kde_roadSG_bw_raster) +
  tm_raster(style = "cont", palette = "plasma") +
  tm_layout(legend.show = TRUE, legend.text.color = "white") +
  osm_layer
```

# 6.0 Network Constrained KDE (NetKDE) Analysis

In this section, we will perform NetKDE analysis by using appropriate functions provided in **spNetwork** package.

## 6.1 Extracting study area

The code chunk below will be used to extract the target planning areas at Punggol, Tampines, Chua Chu Kang and Jurong West.

```{r}
pung <- islandMe %>%
  filter(PLN_AREA_N == "PUNGGOL")
pung <- pung%>%
  st_union()
pung <- st_make_valid(pung)
```

```{r}
tamp <- islandMe %>%
  filter(PLN_AREA_N == "TAMPINES")
tamp <- tamp%>%
  st_union()
tamp <- st_make_valid(tamp)
```

```{r}
cck <- islandMe %>%
  filter(PLN_AREA_N == "CHOA CHU KANG")
cck <- cck%>%
  st_union()
cck <- st_make_valid(cck)
```

```{r}
jw <- islandMe %>%
  filter(PLN_AREA_N == "JURONG WEST")
jw <- jw%>%
  st_union()
jw <- st_make_valid(jw)
```

```{r}
pung <- st_transform(pung, crs = 3414)
tamp <- st_transform(tamp, crs = 3414)
cck <- st_transform(cck, crs = 3414)
jw <- st_transform(jw, crs = 3414)
```

Retrieving roads within target planning areas

```{r}
pung_roads <- st_intersection(roads_in_singapore, pung)
tamp_roads <- st_intersection(roads_in_singapore, tamp)
cck_roads <- st_intersection(roads_in_singapore, cck)
jw_roads <- st_intersection(roads_in_singapore, jw)
```

Plotting target planning areas

```{r}
par(mfrow=c(2,2))
plot(pung, main = "Punggol")
plot(tamp, main = "Tampines")
plot(cck, main = "Choa Chu Kang")
plot(jw, main = "Jurong West")
```

The code chunk below is used to plot the roads of these four study areas.

```{r}
tmap_mode('plot')
tmap_arrange(tm_shape(pung_roads) +
               tm_lines(col = "red") +
               tm_layout(title = "Punggol", title.size = 0.8),
             tm_shape(tamp_roads) +
               tm_lines(col = "blue") +
               tm_layout(title = "Tampines", title.size = 0.8), 
             tm_shape(cck_roads) +
               tm_lines(col = "green") +
               tm_layout(title = "Choa Chu Kang", title.size = 0.8),
             tm_shape(jw_roads) +
               tm_lines(col = "orange") +
               tm_layout(title = "Jurong West", title.size = 0.8),
             asp=2, ncol=2)
```

Converting them to **linestring** format

```{r}
pung_roads <- st_cast(pung_roads, "LINESTRING")
tamp_roads <- st_cast(tamp_roads, "LINESTRING")
cck_roads <- st_cast(cck_roads, "LINESTRING")
jw_roads <- st_cast(jw_roads, "LINESTRING")
```

## 6.2 Preparing the lixels objects

Before computing NetKDE, the SpatialLines object need to be cut into lixels with a specified minimal distance. This task can be performed by using with lixelize_lines() of spNetwork as shown in the code chunk below.

```{r}
lixels_pung <- lixelize_lines(pung_roads, 
                         700, 
                         mindist = 350)
lixels_tamp <- lixelize_lines(tamp_roads, 
                         700, 
                         mindist = 350)
lixels_cck <- lixelize_lines(cck_roads, 
                         700, 
                         mindist = 350)
lixels_jw <- lixelize_lines(jw_roads, 
                         700, 
                         mindist = 350)
```

## 6.3 Generating line centre points

Next, lines_center() of **spNetwork** will be used to generate a SpatialPointsDataFrame (i.e. samples) with line centre points as shown in the code chunk below.

```{r}
samples_pung <- lines_center(lixels_pung)
samples_tamp <- lines_center(lixels_tamp)
samples_cck <- lines_center(lixels_cck)
samples_jw <- lines_center(lixels_jw)
```

```{r}
origin_pung = st_intersection(listings_sf, pung)
origin_tamp = st_intersection(listings_sf, tamp)
origin_cck = st_intersection(listings_sf, cck)
origin_jw = st_intersection(listings_sf, jw)
```

To visualise the geospatial data with high cartographic quality and interactive manner, the mapping function of **tmap** package can be used as shown in the code chunk below.

::: {.panel-tabset .nav-pills}
## Punggol

```{r}
tmap_mode('view')
tm_basemap("OpenStreetMap") +
tm_shape(pung_roads) +
  tm_lines(col = "red") +
  tm_shape(origin_pung) + 
  tm_dots()
tmap_mode('plot')
```

## Tampines

```{r}
tmap_mode('view')
tm_basemap("OpenStreetMap") +
tm_shape(tamp_roads) +
  tm_lines(col = "blue") +
  tm_shape(origin_tamp) + 
  tm_dots()
tmap_mode('plot')
```

## Choa Chu Kang

```{r}
tmap_mode('view')
tm_basemap("OpenStreetMap") +
tm_shape(cck_roads) +
  tm_lines(col = "green") +
  tm_shape(origin_cck) + 
  tm_dots()
tmap_mode('plot')
```

## Jurong West

```{r}
tmap_mode('view')
tm_basemap("OpenStreetMap") +
tm_shape(jw_roads) +
  tm_lines(col = "orange") +
  tm_shape(origin_jw) + 
  tm_dots()
tmap_mode('plot')
```
:::

The points are located at center of the line based on the length of the line.

## 6.4 Performing NetKDE

We are ready to compute the NetKDE by using the code chunk below.

::: {.panel-tabset .nav-pills}
## Punggol

```{r}
densities_pung <- nkde(pung_roads, 
                  events = origin_pung,
                  w = rep(1,nrow(origin_pung)),
                  samples = samples_pung,
                  kernel_name = "quartic",
                  bw = 300, 
                  div= "bw", 
                  method = "simple", 
                  digits = 1, 
                  tol = 1,
                  grid_shape = c(1,1), 
                  max_depth = 8,
                  agg = 5, #we aggregate events within a 5m radius (faster calculation)
                  sparse = TRUE,
                  verbose = FALSE)
```

## Tampines

```{r}
densities_tamp <- nkde(tamp_roads, 
                  events = origin_tamp,
                  w = rep(1,nrow(origin_tamp)),
                  samples = samples_tamp,
                  kernel_name = "quartic",
                  bw = 300, 
                  div= "bw", 
                  method = "simple", 
                  digits = 1, 
                  tol = 1,
                  grid_shape = c(1,1), 
                  max_depth = 8,
                  agg = 5, #we aggregate events within a 5m radius (faster calculation)
                  sparse = TRUE,
                  verbose = FALSE)
```

## Choa Chu Kang

```{r}
densities_cck <- nkde(cck_roads, 
                  events = origin_cck,
                  w = rep(1,nrow(origin_cck)),
                  samples = samples_cck,
                  kernel_name = "quartic",
                  bw = 300, 
                  div= "bw", 
                  method = "simple", 
                  digits = 1, 
                  tol = 1,
                  grid_shape = c(1,1), 
                  max_depth = 8,
                  agg = 5, #we aggregate events within a 5m radius (faster calculation)
                  sparse = TRUE,
                  verbose = FALSE)
```

## Jurong West

```{r}
densities_jw <- nkde(jw_roads, 
                  events = origin_jw,
                  w = rep(1,nrow(origin_jw)),
                  samples = samples_jw,
                  kernel_name = "quartic",
                  bw = 300, 
                  div= "bw", 
                  method = "simple", 
                  digits = 1, 
                  tol = 1,
                  grid_shape = c(1,1), 
                  max_depth = 8,
                  agg = 5, #we aggregate events within a 5m radius (faster calculation)
                  sparse = TRUE,
                  verbose = FALSE)
```
:::

Before we can visualise the NetKDE values, the code chunk below will be used to insert the computed density values (i.e. densities) into samples and lixels objects as density field.

::: callout-note
Since svy21 projection system is in meter, the computed density values are very small i.e. 0.0000005. The code chunk below is used to resale the density values from number of events per meter to number of events per kilometer.
:::

::: {.panel-tabset .nav-pills}
## Punggol

```{r}
samples_pung$density <- densities_pung
lixels_pung$density <- densities_pung
# rescaling to help the mapping
samples_pung$density <- samples_pung$density*1000
lixels_pung$density <- lixels_pung$density*1000
```

## Tampines

```{r}
samples_tamp$density <- densities_tamp
lixels_tamp$density <- densities_tamp
# rescaling to help the mapping
samples_tamp$density <- samples_tamp$density*1000
lixels_tamp$density <- lixels_tamp$density*1000
```

## Choa Chu Kang

```{r}
samples_cck$density <- densities_cck
lixels_cck$density <- densities_cck
# rescaling to help the mapping
samples_cck$density <- samples_cck$density*1000
lixels_cck$density <- lixels_cck$density*1000
```

## Jurong West

```{r}
samples_jw$density <- densities_jw
lixels_jw$density <- densities_jw
# rescaling to help the mapping
samples_jw$density <- samples_jw$density*1000
lixels_jw$density <- lixels_jw$density*1000
```
:::

The code below uses appropriate functions of tmap package to prepare interactive and high cartographic quality map visualisation.

::: {.panel-tabset .nav-pills}
## Punggol

```{r}
tmap_mode('plot')
tm_shape(lixels_pung)+
  tm_lines(col="density")+
tm_shape(origin_pung)+
  tm_dots()
```

## Tampines

```{r}
tmap_mode('plot')
tm_shape(lixels_tamp)+
  tm_lines(col="density")+
tm_shape(origin_tamp)+
  tm_dots()
```

## Choa Chu Kang

```{r}
tmap_mode('plot')
tm_shape(lixels_cck)+
  tm_lines(col="density")+
tm_shape(origin_cck)+
  tm_dots()
```

## Jurong West

```{r}
tmap_mode('plot')
tm_shape(lixels_jw)+
  tm_lines(col="density")+
tm_shape(origin_jw)+
  tm_dots()
```
:::

The interactive map above effectively reveals road segments (darker color) with relatively higher density of Grab taxi location points than road segments with relatively lower density of Grab taxi location points (lighter color).


# 7.0 Conclusions

In conclusion, the Grab Posisi data has enabled us to analyze the distribution of pick-up points in Singapore. The majority of these points are evenly spread across the four locations, as previously demonstrated. It's evident that most pick-up points are situated near main roads, likely for the convenience of drivers, allowing them to easily navigate or proceed towards their destination. With this understanding, Grab could potentially consider implementing more competitive pricing for pick-ups near main roads compared to those in residential areas, which may enhance its competitiveness against rivals like Gojek.

Therefore, there are numerous insights to be gleaned from the available data, each subject to individual interpretation. Other factors may also contribute to the prevalence of pick-up points near main roads, for instance, the data pertains to 2019 when the Grab app might have restricted users from freely selecting pick-up locations, automatically opting for the nearest road instead. Consequently, the full extent of the reasons behind the observed data remains unclear. That's why it is essential to gather additional data moving forward, as it can aid us in generating more comprehensive insights.